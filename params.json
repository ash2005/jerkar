{"name":"Jerkar","tagline":"The 100% Java Build Tool","body":"![Logo of Jerkar](https://github.com/jerkar/jerkar/blob/master/doc/jerkar.png)\r\n\r\nJerkar is a complete built system ala Maven or Gradle but using only a **Java** internal DSL to describe builds : no XML, no foreign language.\r\nIt is intended to build project written in Java language but can also be used for any task execution purpose.\r\n\r\n# Motivation\r\nSo far, for building their projects, java developers generally use an XML based (**Ant**, **Maven**) or a foreign language DSL (**Gradle**, **Rake**, **SBT**, ...) tool.\r\nThey just can't use **Java** to create organization scalable builds. **Jerkar** purposes to fill this gap.\r\n      \r\nYet, using Java for building a Java based project brings quite valuable benefits :\r\n* You don't have to learn an extra language or XML soup just for build purpose : get higher cohesion and lower cognitive load\r\n* You leverage directly the power and flexibility of Java\r\n* You leverage compilation, code-completion and debug facilities provided by your IDE without installing 3rd party plugins/tools. For static typed language as Java, it notably brings robustness to your builds\r\n* Your builds can benefit from any libraries without needing to wrap it in a plugin or a specific component\r\n* You can master build complexity the same way you do for regular code (ie utility classes, SoC, inheritance, composition,...) \r\n* Using fluent style internal DSL, syntax is much more concise and explicit than an XML description\r\n* It's easier to dig into the build engine to investigate on behavior as builds are in essence, only API calls\r\n\r\nAdditionally the following features were missing from mainstream existing tools :\r\n* Run pluggable extra features (test coverage, special packaging, static code analysis,...) without editing the build file\r\n* Write nothing-at-all for building simple/standard projects (just relying on convention and/or IDE meta-data files, even to launch static analysis tools or generate ear/war files)\r\n\r\n## Overcoming Java shortcomings\r\nOne believes that the verbosity and the statically typed nature of Java make it hardly suitable for expressing builds.\r\nJerkar tends to prove the opposite :\r\n* Jerkar transparently compiles the java build classes prior to execute them. This step is very quick, Jerkar velocity does not suffer from this 'extra' step\r\n* Jerkar heavily relies on convention and sensitive defaults : you only need to specify what is not 'standard'\r\n* Jerkar features fluent APIs whose allow to express tasks in a very concise way. Jerkar build classes are close to Gradle script concision (and even more in certain cases) \r\n* Jerkar comes with no 3rd party dependency (except Ivy) to avoid version clashing.\r\n* Jerkar keeps the runtime simple (no bytecode enhancement) for easier debugging \r\n\r\n# Main features\r\nJerkar provides what a self respecting modern, enterprise scale, build system should and more :\r\n* Provides both APIs and a command line tool.\r\n* Multi level of configuration system (Jerkar instance, user, build class, build command line)\r\n* Powerfull dependency management (back-ended by Ivy so compatible with Maven repositories)\r\n* Publication on Ivy or Maven repositories\r\n* Multi-project support\r\n* Powerfull fluent API to manipulate files, perform  compilations, tests, archives and all build related stuff\r\n* Choice between free form builds (ala Ant) and enforced build templates (ala Maven)\r\n* Hierarchical log output tracking execution time for each intermediate step\r\n* Pluggable architecture\r\n* Ability to get information from naming convention and Eclipse files, so in simpler cases you won't need to write script at all (even to generate war or perform SonarQube analysis) !!!\r\n\r\n\r\nThe documentation is at its very early stage but the code is yet pretty close to completion for a first release. \r\nI mainly need help for further testing, writing documentation, polishing the API... and getting some feedback of course.\r\n\r\n# How to build\r\nJerkar is made of following projects :\r\n* core : complete Jerkar project but without embedding following plugins\r\n* plugins-jacoco : a plugin to perform test coverage\r\n* plugins-sonar : a plugin to perform sonar analysis\r\n* distrib-all : the core distrib augmented with the above plugins\r\n\r\nJerkar builds with itself. To get Jerkar full distrib built from the Java sources only, the simpler is to import these 4 projects in Eclipse, then :\r\n* Create a Java Application run configuration (Run Configuration ... -> Java Application -> new)\r\n  * Make sure that the Runtime JRE is a JDK (6 or above)\r\n  * Choose `org.jerkar.distrib-all` as project\r\n  * Choose `org.jerkar.Main` as Main class\r\n* Run it : It will launch a multi-project build. You will find result for the full distrib in *org.jerkar.distrib-all/build/output* directory \r\n\r\n# Quick start\r\n1. Add the org.jerkar.core-fat.jar (found in the distrib) in your IDE build-path. This jar includes Jerkar core along plugins classes\r\n2. Create a `build/spec` folder at the base of your project and make it a source folder in your IDE. In Jerkar, all related build stuff (build definition, local 3rd party libs, produced artifacts,...) lies under *build* directory\r\n3. Write the build class extending JkJavaBuild in this directory (in whatever package)\r\n4. If your project respect convention, do not need managed dependencies and don't do 'special' thing, you don't even need 2) and 3) points\r\n5. Launch the `org.jerkar.Main` class in your IDE or type `jerkar` in the command line (with the root of your project as working directory)\r\n\r\nThis will launch the `doDefault` method defined in your build class. Note that this method is declared in the `JkJavaBuild` and invoke in sequence clean, compile, unitTest and pack methods.\r\n\r\nIf you want to launch several methods of your build, type `jerkar doSomething doSomethingElse`. Jerkar recognizes any public zero-argument method returning `void` as build method.\r\nType `jerkar help` to get all the build methods provided by your build class. \r\n  \r\n\r\n## Example : Let's see how Jerkar core build itself\r\n\r\nJerkar core build is not complex but do some specific stuff : apart making standard compilation, junit tests and jar packaging, it constructs a distribution archive gathering jars, sources, property, readme files and executable.\r\nThis is the build class :\r\n\r\n```java\r\n    public class CoreBuild extends JkJavaBuild {\r\n\r\n\t    public File distripZipFile; // The zip file that will contain the whole distrib\r\n\r\n\t    public File distribFolder;  // The folder that will contain the whole distrib\r\n\r\n\t    @Override\r\n\t    protected void init() {\r\n\t        distripZipFile = ouputDir(\"jerkar-distrib.zip\");\r\n            distribFolder = ouputDir(\"jerkar-distrib\");\r\n\t\t    this.fatJar = true;\r\n        }\r\n\r\n\t    // Interpolize resource files replacing ${version} by a timestamp (in the Manifest)\r\n\t    @Override\r\n\t    protected JkResourceProcessor resourceProcessor() {\r\n\t\t    return super.resourceProcessor().with(\"version\", version().name() + \" - built at - \" + buildTimestamp());\r\n\t    }\r\n\r\n\t    // Include the making of the distribution into the application packaging.\r\n\t    @Override\r\n\t    public void pack() {\r\n\t\t    super.pack();\r\n\t\t    distrib();\r\n\t    }\r\n\r\n        // Create a distribution of Jerkar core, including jars, sources and windows/linux launch scripts\r\n\t    private void distrib() {\r\n\t\t    final JkDir distrib = JkDir.of(distribFolder);\r\n\t\t    JkLog.startln(\"Creating distrib \" + distripZipFile.getPath());\r\n\t\t    final JkJavaPacker packer = packer();\r\n\t\t    distrib.importDirContent(baseDir(\"src/main/dist\"));\r\n\t\t    distrib.importFiles(packer.jarFile(), packer.fatJarFile());\r\n\t\t    distrib.sub(\"libs/required\").importDirContent(baseDir(\"build/libs/compile\"));\r\n\t\t    distrib.sub(\"libs/sources\").importDirContent(baseDir(\"build/libs-sources\"))\r\n\t\t                                  .importFiles(packer.jarSourceFile());\r\n\t\t\tdistrib.zip().to(distripZipFile, Deflater.BEST_COMPRESSION);\r\n\t\t\tJkLog.done();\r\n\t    }\r\n\t}\r\n```\r\n\r\nNotice that we need only to specify what is not 'standard'\r\n* group and project name are inferred from the project folder name ('org.jerkar.core' so group is 'org.jerkar' and project is 'core')\r\n* version is not specified, so by default it is `1.0-SNAPSHOT`(unless you inject the version via the command line using `-forcedVersion=Xxxxx`)\r\n* sources, resources and tests folder are located on the conventional folders (same as Maven).\r\n* this build class relies on local dependencies (dependencies located conventionally inside the project) so we don't need to mention them\r\n\r\nA dependency managed flavor of this build is [CoreDepManagedBuild.java](https://github.com/jerkar/jerkar/blob/master/org.jerkar.core/build/spec/org/jerkar/CoreDepManagedBuild.java)\r\n\r\nTo launch the build for creating distrib from the command line, simply type : \r\n\r\n    jerkar\r\n\r\nThis will interpole resources (replacing ${version} by a timestamp everywhere), compile, run unit tests, create jars and package the distrib in zip file. \r\nThis command is equivalent to `jerkar doDefault` : when no method specified, Jerkar invoke the `doDefault` method. Build result is *output* folder : \r\n\r\n![image of project layout](https://github.com/jerkar/jerkar/blob/master/doc/project-layout.png)\r\n\r\n---\r\nTo launch a SonarQube analysis along test coverage and producing javadoc: \r\n\r\n    jerkar clean compile unitTest sonar#verify javadoc jacoco# -verbose=true\r\n    \r\nThis will compile, unit test with test coverage, launch a sonar analysis with sonar user settings and finally produce the javadoc. \r\n- `clean`, `compile`, `unitTest` and `javadoc` are build methods inherited by `CoreBuild`\r\n- `sonar#verify` means that Jerkar will invoke a method called `verify`in the `sonar` plugin class\r\n- `jacoco#` means that the `jacoco` plugin will be activated while the junit test will be running\r\n- `-verbose=true`means that the log will display verbose information ('-' prefix is the way to pass parameter in Jerkar)\r\n\r\n\r\nNotice that Jacoco test coverage and SonarQube analysis are triggered without mention in the build class ! \r\n    \r\n    \r\n        ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}